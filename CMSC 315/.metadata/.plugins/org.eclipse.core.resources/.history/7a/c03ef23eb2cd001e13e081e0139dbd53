package project_3;
import java.util.ArrayList;

public class BinaryTree {
	private TreeNode root;
	
	private static class TreeNode{
		int val;
		TreeNode left;
		TreeNode right;
		
		public TreeNode(int val){
			this.val = val;
		}
	}
	
	private TreeNode buildTree(String preorder) {
		if (preorder == null || preorder.isEmpty()) {
	        return null;
	    }

	    // Find the start and end indices for the root value
	    int rootValStart = preorder.indexOf('(') + 1;
	    int rootValEnd = preorder.indexOf(' ', rootValStart); // Find the first space after the opening parenthesis
	    if (rootValEnd == -1) {
	        rootValEnd = preorder.indexOf(')', rootValStart); // If there's no space, find the closing parenthesis
	    }
	    int rootVal = Integer.parseInt(preorder.substring(rootValStart, rootValEnd));

	    // Find the start and end indices for the left subtree
	    int leftStart = preorder.indexOf('(', rootValEnd) + 1;
	    int leftEnd = findMatchingParenthesis(preorder, leftStart);
	    String leftSubtree = leftEnd == -1 ? "" : preorder.substring(leftStart, leftEnd);

	    // Find the start and end indices for the right subtree
	    int rightStart = leftEnd + 3; // Skip the closing parenthesis and space
	    int rightEnd = findMatchingParenthesis(preorder, rightStart);
	    String rightSubtree = rightEnd == -1 ? "" : preorder.substring(rightStart, rightEnd);

	    // Construct the root node and recursively build the left and right subtrees
	    TreeNode root = new TreeNode(rootVal);
	    root.left = buildTree(leftSubtree);
	    root.right = buildTree(rightSubtree);

	    return root;
	}
	
	private int findMatchingParenthesis(String str, int start) {
        int count = 0;
        for (int i = start; i < str.length(); i++) {
            if (str.charAt(i) == '(') {
                count++;
            } else if (str.charAt(i) == ')') {
                count--;
                if (count == 0) {
                    return i;
                }
            }
        }
        return -1; // Matching parenthesis not found
    }
	
	private TreeNode buildBalancedTree(int[] values, int start, int end) {
		if (start > end)
			return null;
		int mid = (start + end) / 2;
		TreeNode node = new TreeNode(values[mid]);
		node.left = buildBalancedTree(values, start, mid - 1);
		node.right = buildBalancedTree(values, mid + 1, end);
		return node;
	}
	
	public BinaryTree(String preorder) {
		this.root = buildTree(preorder);
	}
	
	public BinaryTree(ArrayList<Integer> values) {
		int[] valArr = new int[values.size()];
		for(int i = 0; i < values.size(); i++)
			valArr[i] = values.get(i);
		this.root = buildBalancedTree(valArr, 0, valArr.length - 1);
	}
	
	public void printIndented() {
		printIndented(root, 0);
	}
	
	public void printIndented(TreeNode node, int depth) {
		if (node == null)
			return;
		for (int i = 0; i < depth; i++)
			System.out.print("  ");
		System.out.println(node.val);
		printIndented(node.left, depth + 1);
		printIndented(node.right, depth + 1);
	}
	
	public int getHeight() {
		return height(root);
	}
	
	private int height(TreeNode node) {
		if (node == null) {
			return -1;
		}
		int leftHeight = height(node.left);
		int rightHeight = height(node.right);
		
		return Math.max(leftHeight, rightHeight) + 1;
	}
	
	public boolean isBalanced() {
		return checkHeight(root) != -1;
	}
	
	private int checkHeight(TreeNode node) {
		if (node == null)
			return 0;
		int leftHeight = checkHeight(node.left);
		if (leftHeight == -1)
			return -1;
		int rightHeight = checkHeight(node.right);
		if (rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1)
			return -1;
		return Math.max(leftHeight, rightHeight) + 1;
		
	}
	
	public ArrayList<Integer> getValues() {
		ArrayList<Integer> values = new ArrayList<>();
		preOrderTraversal(root, values);
		return values;
	}
	
	public void preOrderTraversal(TreeNode node, ArrayList<Integer> values) {
		if (node != null) {
			values.add(node.val);
			preOrderTraversal(node.left, values);
			preOrderTraversal(node.right, values);
		}
	}
}
