package project_3;
import java.util.ArrayList;

public class BinaryTree {
	private TreeNode root;
	
	private static class TreeNode{
		int val;
		TreeNode left;
		TreeNode right;
		
		public TreeNode(int val){
			this.val = val;
		}
	}
	
	private TreeNode buildTree(String preorder) {
		
		if (preorder == null || preorder.isEmpty() || preorder.charAt(0) != '(') {
	        return null;
	    }
	    
	    int rootValEnd = preorder.indexOf(' ');
	    int rootVal = Integer.parseInt(preorder.substring(1, rootValEnd));
	    TreeNode root = new TreeNode(rootVal);
	    
	    if (findMatchingParenthesis(preorder, rootValEnd + 1) == -1) {
	    	root.left = null;
	    	root.right = null;
	    	return root;
	    }
	    int leftSubtreeEnd = findMatchingParenthesis(preorder, rootValEnd + 1);
	    String leftSubtree = extractSubtree(preorder, rootValEnd + 1, leftSubtreeEnd);
	    root.left = leftSubtree.equals("*") ? null : buildTree(leftSubtree);
	    
	    int rightSubtreeEnd = findMatchingParenthesis(preorder, leftSubtreeEnd + 1);
	    String rightSubtree = extractSubtree(preorder, leftSubtreeEnd + 1, rightSubtreeEnd);
	    root.right = rightSubtree.equals("*") ? null : buildTree(rightSubtree);
	    
	    return root;
	}

	private String extractSubtree(String preorder, int start, int end) {
		if (start > end) {
	        return "";
	    }
	    return preorder.substring(start, end + 1).trim();
	}
	
	private int findMatchingParenthesis(String preorder, int start) {
	    int count = 0;
	    for (int i = start; i < preorder.length(); i++) {
	        char c = preorder.charAt(i);
	        if (c == '(') {
	            count++;
	        } else if (c == ')') {
	            count--;
	            if (count == 0) {
	                return i;
	            }
	        }
	    }
	    return -1; // Indicates no matching closing parenthesis found
	}
	
	private TreeNode buildBalancedTree(int[] values, int start, int end) {
		if (start > end)
			return null;
		int mid = (start + end) / 2;
		TreeNode node = new TreeNode(values[mid]);
		node.left = buildBalancedTree(values, start, mid - 1);
		node.right = buildBalancedTree(values, mid + 1, end);
		return node;
	}
	
	public BinaryTree(String preorder) {
		this.root = buildTree(preorder);
	}
	
	public BinaryTree(ArrayList<Integer> values) {
		int[] valArr = new int[values.size()];
		for(int i = 0; i < values.size(); i++)
			valArr[i] = values.get(i);
		this.root = buildBalancedTree(valArr, 0, valArr.length - 1);
	}
	
	public void printIndented() {
		printIndented(root, 0);
	}
	
	public void printIndented(TreeNode node, int depth) {
		if (node == null)
			return;
		for (int i = 0; i < depth; i++)
			System.out.print("  ");
		System.out.println(node.val);
		printIndented(node.left, depth + 1);
		printIndented(node.right, depth + 1);
	}
	
	public int getHeight() {
		return height(root);
	}
	
	private int height(TreeNode node) {
		if (node == null) {
			return -1;
		}
		int leftHeight = height(node.left);
		int rightHeight = height(node.right);
		
		return Math.max(leftHeight, rightHeight) + 1;
	}
	
	public boolean isBalanced() {
		return checkHeight(root) != -1;
	}
	
	private int checkHeight(TreeNode node) {
		if (node == null)
			return 0;
		int leftHeight = checkHeight(node.left);
		if (leftHeight == -1)
			return -1;
		int rightHeight = checkHeight(node.right);
		if (rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1)
			return -1;
		return Math.max(leftHeight, rightHeight) + 1;
		
	}
	
	public boolean isValidBST() {
	    return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}

	private boolean isValidBST(TreeNode node, int min, int max) {
	    if (node == null) {
	        return true;
	    }
	    if (node.val <= min || node.val >= max) {
	        return false;
	    }
	    return isValidBST(node.left, min, node.val) && isValidBST(node.right, node.val, max);
	}
	
	public ArrayList<Integer> getValues() {
		ArrayList<Integer> values = new ArrayList<>();
		preOrderTraversal(root, values);
		return values;
	}
	
	public void preOrderTraversal(TreeNode node, ArrayList<Integer> values) {
		if (node != null) {
			values.add(node.val);
			preOrderTraversal(node.left, values);
			preOrderTraversal(node.right, values);
		}
	}
}
